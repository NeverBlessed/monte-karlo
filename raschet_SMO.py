import math
import numpy as np


# первое задание
def task1(k, v, n, lamb, b):
    mu = v / n  # Интенсивность обслуживания заявок
    p = lamb / mu  # Интенсивность нагрузки
    m = (b-1)*k  # Максимальная длина очереди
    s = m  # Так как нам нужна максимальная длина очереди при расчетах

    # рассчет вероятности по формуле для k-канальной СМО смешанного типа

    res2 = 1
    for i in range(1, s+1):
        res2 *= k

    res4 = 0
    for i in range(0, k+1):
        res4 += ((p**i) / (math.factorial(i)))

    res5 = p**k / math.factorial(k)

    res6 = 0
    for i in range(1, m+1):
        res1 = 1
        for j in range(1, i+1):
            res1 *= k
        res6 += p**i / res1

    return (p**s / res2) * ((p**k)/(math.factorial(k))) / (res4 + res5 * res6)


# функции для второго задания
def in_time(a, x):  # функция, проверяющая есть ли каналы в массиве a, успевшие обработать последний запрос ко времени x
    for i in a:
        if i < x:
            return True
    return False


def model_day():
    # Количество пакетов
    n_packets = 10000

    # Текущее время
    t = 0

    # количество каналов
    n = 5

    # Интесивность входного потока
    lambda_day = 5

    # Максимальный размер очереди канала
    m = 3

    # Интенсивность выходного потока
    mu = 2

    # время, когда прибор освободится
    t_free = np.array([0, 0, 0, 0, 0])

    # количество занятых каналов
    s = 0

    # массив очередей, где индекс - номер канала, значение - количество пакетов в очереди
    queue = np.array([0, 0, 0, 0, 0])  # если в i-той ячейке хранится 0 значит i-тый канал свободен

    # массив логических значений, показывающий свободен ли i-тый канал запрос
    free_canal = [True, True, True, True, True]

    # Количество потярянных пакетов
    n_lost = 0

    for i in range(n_packets):
        # время поступления нового пакета
        t += np.random.exponential(scale=1/lambda_day)

        # проверяем, все ли каналы заняты
        if s == n:

            while s == n and in_time(t_free, t):  # пока все каналы заняты и есть хотя бы один канал обработавший свой
                # последний запрос до времени t
                j = 0
                for c in t_free:  # проход по всем каналам с вычислением времени обработки их последнего запроса
                    if t_free[j] < t:
                        t_free[j] = t + np.random.exponential(scale=1/mu)
                    j += 1

                for k in t_free.argsort():  # проход по каналам в порядке возрастания времени освобождения от последнего
                    # запроса
                    if t_free[k] < t and queue[k] == 0:  # если канал освободился до t и его очередь пуста, освобождаем
                        # его
                        s -= 1
                        free_canal[k] = True
                    if t_free[k] < t and queue[k] > 0:  # если канал освободился до t и его очередь не пуста,
                        # передаем ему следующий пакет из очереди
                        queue[k] -= 1

        if not in_time(t_free, t):  # если после первого цикла все каналы не успели обработать последний запрос
            if queue[queue.argsort()[0]] == m:  # и канал с самой маленькой очередью загружен
                n_lost += 1                     # пакет теряется
            else:                               # если его очередь не максимальная
                queue[queue.argsort()[0]] += 1  # добавляем элемент в эту очередь

        if s < n:  # если есть свободные каналы, проходим по каналам в порядке возрастания времени освобождения
            # от последнего запроса, если канал свободен, передаем ему пакет и выходим из цикла
            for k in t_free.argsort():
                if free_canal[k]:
                    free_canal[k] = False
                    s += 1
                    break

    return n_lost/n_packets


def model_night():
    # Количество пакетов
    n_packets = 1000

    # Текущее время
    t = 0

    # количество каналов
    n = 5

    # Интесивность входного потока
    lambda_night = 0.5

    # Максимальный размер очереди канала
    m = 3

    # Интенсивность выходного потока
    mu = 2

    # время, когда прибор освободится
    t_free = np.array([0, 0, 0, 0, 0])

    # количество занятых каналов
    s = 0

    # массив очередей, где индекс - номер канала, значение - количество пакетов в очереди
    queue = np.array([0, 0, 0, 0, 0])  # если в i-той ячейке хранится 0 значит i-тый канал свободен

    # массив логических значений, показывающий свободен ли i-тый канал запрос
    free_canal = [True, True, True, True, True]

    # Количество потярянных пакетов
    n_lost = 0

    for i in range(n_packets):
        # время поступления нового пакета
        t += np.random.exponential(scale=1/lambda_night)

        # проверяем, все ли каналы заняты
        if s == n:

            while s == n and in_time(t_free, t):  # пока все каналы заняты и есть хотя бы один канал обработавший свой
                # последний запрос до времени t
                j = 0
                for c in t_free:  # проход по всем каналам с вычислением времени обработки их последнего запроса
                    if t_free[j] < t:
                        t_free[j] = t + np.random.exponential(scale=1/mu)
                    j += 1

                for k in t_free.argsort():  # проход по каналам в порядке возрастания времени освобождения от последнего
                    # запроса
                    if t_free[k] < t and queue[k] == 0:  # если канал освободился до t и его очередь пуста, освобождаем
                        # его
                        s -= 1
                        free_canal[k] = True
                    if t_free[k] < t and queue[k] > 0:  # если канал освободился до t и его очередь не пуста,
                        # передаем ему следующий пакет из очереди
                        queue[k] -= 1

        if not in_time(t_free, t):  # если после первого цикла все каналы не успели обработать последний запрос
            if queue[queue.argsort()[0]] == m:  # и канал с самой маленькой очередью загружен
                n_lost += 1                     # пакет теряется
            else:                               # если его очередь не максимальная
                queue[queue.argsort()[0]] += 1  # добавляем элемент в эту очередь

        if s < n:  # если есть свободные каналы, проходим по каналам в порядке возрастания времени освобождения
            # отпоследнего запроса, если канал свободен, передаем ему пакет и выходим из цикла
            for k in t_free.argsort():
                if free_canal[k]:
                    free_canal[k] = False
                    s += 1
                    break

    return n_lost/n_packets


# вывод результатов на экран
def main():
    # вывод на экран результатов первого задания
    print(task1(5, 2400, 1200, 5, 4))
    print(task1(5, 2400, 1200, 0.5, 4))

    # второе задание
    # Инициализация генеротора случайных чисел
    np.random.seed(500)

    # Количество повторов в методе Монте-Карло
    n_rep = 5000

    # Вероятность блокировки
    p_refuse = 0

    # Имитационное моделирование
    for i in range(n_rep):
        p_refuse += model_day()

    # Оценка вероятности блокировки
    p_refuse /= n_rep
    # вывод на экран дневной вероятности блокировки по результатам 2 задания
    print('daily average probability = ' + str(p_refuse))

    # Инициализация генеротора случайных чисел
    np.random.seed(100)

    # Количество повторов в методе Монте-Карло
    n_rep = 1000

    # Вероятность блокировки
    p_refuse = 0

    # Имитационное моделирование
    for i in range(n_rep):
        p_refuse += model_night()

    # Оценка вероятности блокировки
    p_refuse /= n_rep
    # вывод на экран ночной вероятности блокировки по результатам 2 задания
    print('night average probability = ' + str(p_refuse))


if __name__ == "__main__":
    main()

"""
1) вероятность блокировки днем 1.989312085027311e-06 (примерно 2 * 10^(-6))
    вероятность блокировки ночью 1.9341725521542174e-25 (примерно 2 * 10^(-25))
2) вероятность блокировки по методу Монте-Карло:
    днем 1.4 * 10^(-5) (при 1000 повторений)
    днем 1.84 * 10^(-5) (при 5000 повторений)
    ночью стремится к 0
"""
